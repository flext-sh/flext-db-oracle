"""End-to-end tests for flext-db-oracle with complete Oracle workflow simulation.

These tests simulate complete real-world scenarios using Docker containers
or test databases to validate the entire system works end-to-end.

Copyright (c) 2025 FLEXT Team. All rights reserved.
SPDX-License-Identifier: MIT

"""

from __future__ import annotations

import os
from unittest.mock import patch

import pytest

from flext_db_oracle import (
    FlextDbOracleApi,
    FlextDbOracleConfig,
)


class TestOracleE2E:
    """End-to-end tests for Oracle database operations."""

    # Remove test_config fixture - use real_oracle_config from conftest.py

    @pytest.mark.e2e
    def test_complete_oracle_workflow(
        self,
        real_oracle_config: FlextDbOracleConfig,
    ) -> None:
        """Test complete Oracle workflow end-to-end.

        This test validates:
        1. Configuration from environment
        2. Connection establishment
        3. Schema discovery
        4. Table creation
        5. Data insertion
        6. Data querying
        7. Table cleanup
        8. Disconnection
        """
        with FlextDbOracleApi(real_oracle_config) as api:
            # Test connection
            connection_test = api.test_connection()
            assert connection_test.success, (
                f"Connection failed: {connection_test.error}"
            )

            # Test schema discovery
            schemas_result = api.get_schemas()
            assert schemas_result.success, (
                f"Schema discovery failed: {schemas_result.error}"
            )
            assert len(schemas_result.data) > 0, "No schemas found"

            # Test table listing
            tables_result = api.get_tables()
            assert tables_result.success, f"Table listing failed: {tables_result.error}"

            # Test DDL generation and execution
            test_table_name = "E2E_TEST_TABLE"
            columns = [
                {
                    "name": "ID",
                    "type": "NUMBER(10)",
                    "nullable": False,
                    "primary_key": True,
                },
                {"name": "NAME", "type": "VARCHAR2(100)", "nullable": False},
                {"name": "EMAIL", "type": "VARCHAR2(255)", "nullable": True},
                {
                    "name": "CREATED_AT",
                    "type": "TIMESTAMP",
                    "nullable": True,
                    "default_value": "SYSDATE",
                },
            ]

            # Create table
            create_ddl_result = api.create_table_ddl(test_table_name, columns)
            assert create_ddl_result.success, (
                f"DDL generation failed: {create_ddl_result.error}"
            )

            execute_result = api.execute_ddl(create_ddl_result.data)  # nosec B608 # safe DDL generated by API
            assert execute_result.success, (
                f"Table creation failed: {execute_result.error}"
            )

            try:
                # Test data insertion
                insert_sql = f"INSERT INTO {test_table_name} (ID, NAME, EMAIL) VALUES (:id, :name, :email)"  # noqa: S608 # safe table name from test constant with parameterized values

                # Insert test data
                test_data = [
                    {"id": 1, "name": "John Doe", "email": "john@example.com"},
                    {"id": 2, "name": "Jane Smith", "email": "jane@example.com"},
                    {"id": 3, "name": "Bob Wilson", "email": None},
                ]

                for data in test_data:
                    insert_result = api.query(insert_sql, data)  # nosec B608 # safe parameterized query
                    assert insert_result.success, (
                        f"Data insertion failed: {insert_result.error}"
                    )

                # Test data querying
                select_result = api.query(
                    f"SELECT * FROM {test_table_name} ORDER BY ID",  # noqa: S608 # safe table name from test constant
                )
                assert select_result.success, (
                    f"Data query failed: {select_result.error}"
                )
                assert select_result.data.row_count == 3, (
                    f"Expected 3 rows, got {select_result.data.row_count}"
                )

                # Test single row query
                single_result = api.query_one(f"SELECT COUNT(*) FROM {test_table_name}")  # noqa: S608 # safe table name from test constant
                assert single_result.success, (
                    f"Single query failed: {single_result.error}"
                )
                assert single_result.data[0][0] == 3, (
                    f"Expected count 3, got {single_result.data[0][0]}"
                )

                # Test table metadata
                metadata_result = api.get_table_metadata(test_table_name)
                assert metadata_result.success, (
                    f"Metadata query failed: {metadata_result.error}"
                )

                table_metadata = metadata_result.data
                assert table_metadata["table_name"] == test_table_name
                assert (
                    len(table_metadata["columns"]) >= 4
                )  # ID, NAME, EMAIL, CREATED_AT

                # Test column information
                columns_result = api.get_columns(test_table_name)
                assert columns_result.success, (
                    f"Column info failed: {columns_result.error}"
                )
                assert len(columns_result.data) >= 4

                # Test primary keys
                pk_result = api.get_primary_keys(test_table_name)
                assert pk_result.success, f"Primary key query failed: {pk_result.error}"
                assert "ID" in pk_result.data, "ID should be primary key"  # nosec B608

                # Test transaction
                with api.transaction():
                    update_result = api.query(
                        f"UPDATE {test_table_name} SET EMAIL = :email WHERE ID = :id",  # noqa: S608 # safe table name from test constant with parameterized query
                        {"id": 3, "email": "bob@example.com"},
                    )
                    assert update_result.success, (
                        f"Update failed: {update_result.error}"
                    )

                # Verify transaction committed
                verify_result = api.query_one(
                    f"SELECT EMAIL FROM {test_table_name} WHERE ID = 3",  # noqa: S608 # safe table name from test constant
                )
                assert verify_result.success
                assert verify_result.data[0][0] == "bob@example.com"

            finally:
                # Cleanup: Drop test table
                drop_ddl_result = api.drop_table_ddl(test_table_name)
                if drop_ddl_result.success:
                    api.execute_ddl(drop_ddl_result.data)

    @pytest.mark.e2e
    def test_singer_type_conversion_e2e(
        self,
        real_oracle_config: FlextDbOracleConfig,
    ) -> None:
        """Test Singer type conversion in real Oracle environment."""
        with FlextDbOracleApi(real_oracle_config) as api:
            # Test various Singer type conversions
            singer_types = [
                ("string", "VARCHAR2(4000)"),
                ("integer", "NUMBER(38)"),
                ("number", "NUMBER"),
                ("boolean", "NUMBER(1)"),
                ("array", "CLOB"),
                ("object", "CLOB"),
            ]

            for singer_type, expected_oracle_type in singer_types:
                result = api.convert_singer_type(singer_type)
                assert result.success, (
                    f"Type conversion failed for {singer_type}: {result.error}"
                )
                assert expected_oracle_type in result.data, (
                    f"Expected {expected_oracle_type} in {result.data}"
                )

            # Test schema mapping
            singer_schema = {
                "properties": {
                    "id": {"type": "integer"},
                    "name": {"type": "string"},
                    "email": {"type": "string"},
                    "is_active": {"type": "boolean"},
                    "metadata": {"type": "object"},
                    "created_at": {"type": "string", "format": "date-time"},
                },
            }

            schema_result = api.map_singer_schema(singer_schema)
            assert schema_result.success, (
                f"Schema mapping failed: {schema_result.error}"
            )

            mapped_schema = schema_result.data
            assert "id" in mapped_schema
            assert "NUMBER" in mapped_schema["id"]
            assert "name" in mapped_schema
            assert "VARCHAR2" in mapped_schema["name"]
            assert "is_active" in mapped_schema
            assert "NUMBER(1)" in mapped_schema["is_active"]

    @pytest.mark.e2e
    def test_configuration_from_environment_e2e(self) -> None:
        """Test configuration loading from environment variables."""
        test_env = {
            "FLEXT_TARGET_ORACLE_HOST": "e2e-test-host",
            "FLEXT_TARGET_ORACLE_PORT": "1521",
            "FLEXT_TARGET_ORACLE_SERVICE_NAME": "E2EDB",
            "FLEXT_TARGET_ORACLE_USERNAME": "e2e_user",
            "FLEXT_TARGET_ORACLE_PASSWORD": "e2e_password",
            "FLEXT_TARGET_ORACLE_POOL_MIN": "2",
            "FLEXT_TARGET_ORACLE_POOL_MAX": "20",
            "FLEXT_TARGET_ORACLE_TIMEOUT": "60",
        }

        with patch.dict(os.environ, test_env):
            # Test configuration creation
            config_result = FlextDbOracleConfig.from_env()
            assert config_result.success, (
                f"Config creation failed: {config_result.error}"
            )

            config = config_result.data
            assert config.host == "e2e-test-host"
            assert config.port == 1521
            assert config.service_name == "E2EDB"
            assert config.username == "e2e_user"
            assert config.password.get_secret_value() == "e2e_password"
            assert config.pool_min == 2
            assert config.pool_max == 20
            assert config.timeout == 60

            # Test API creation from environment
            api = FlextDbOracleApi.from_env()
            assert isinstance(api, FlextDbOracleApi)
            assert api.config == config

    @pytest.mark.e2e
    def test_error_handling_e2e(self) -> None:
        """Test error handling in end-to-end scenarios."""
        # Test with invalid configuration
        invalid_config = FlextDbOracleConfig(
            host="nonexistent-host.invalid",
            port=9999,
            service_name="INVALID_DB",
            username="invalid_user",
            password="invalid_password",
        )

        api = FlextDbOracleApi(invalid_config)

        # Connection should fail gracefully
        with pytest.raises(ConnectionError, match="Failed to connect"):
            api.connect()

        # Operations without connection should fail gracefully
        query_result = api.query("SELECT 1 FROM DUAL")
        assert query_result.is_failure
        assert "Database not connected" in query_result.error

        metadata_result = api.get_tables()
        assert metadata_result.is_failure
        assert "No database connection" in metadata_result.error

    @pytest.mark.e2e
    def test_concurrent_operations_e2e(
        self,
        real_oracle_config: FlextDbOracleConfig,
    ) -> None:
        """Test concurrent database operations."""
        # This test would be expanded with actual threading/asyncio in a real scenario
        # For now, test sequential operations that simulate concurrent patterns

        api1 = FlextDbOracleApi(real_oracle_config, context_name="connection1")
        api2 = FlextDbOracleApi(real_oracle_config, context_name="connection2")

        # Simulate independent operations
        try:
            # Both APIs should be able to connect independently
            with api1, api2:
                # Test that both connections work
                result1 = api1.query("SELECT 'API1' as source FROM DUAL")
                result2 = api2.query("SELECT 'API2' as source FROM DUAL")

                # Both should succeed (in a real scenario, this would test connection pooling)
                assert (
                    result1.success
                    or os.getenv("SKIP_E2E_TESTS", "true").lower() == "true"
                )
                assert (
                    result2.success
                    or os.getenv("SKIP_E2E_TESTS", "true").lower() == "true"
                )

        except ConnectionError:
            # Expected if no real Oracle instance is available
            pytest.skip("Oracle database not available for concurrent testing")

    @pytest.mark.e2e
    @pytest.mark.benchmark
    def test_performance_benchmark_e2e(
        self,
        real_oracle_config: FlextDbOracleConfig,
    ) -> None:
        """Test performance benchmarks for Oracle operations."""
        # This test would use pytest-benchmark in a real scenario
        # For now, validate that timing information is captured

        try:
            with FlextDbOracleApi(real_oracle_config) as api:
                # Test query with timing
                timed_result = api.query_with_timing("SELECT 1 FROM DUAL")

                if timed_result.success:
                    query_result = timed_result.data
                    assert hasattr(query_result, "execution_time_ms")
                    assert query_result.execution_time_ms >= 0
                    assert hasattr(query_result, "row_count")
                    assert query_result.row_count >= 0

        except ConnectionError:
            # Expected if no real Oracle instance is available
            pytest.skip("Oracle database not available for performance testing")
