"""Oracle Database exceptions using FLEXT ecosystem patterns.

All Oracle-specific exceptions are automatically generated by flext-core.

Copyright (c) 2025 FLEXT Team. All rights reserved.
SPDX-License-Identifier: MIT
"""

from __future__ import annotations

from typing import Final, cast

from pydantic import Field, field_validator

from flext_core import FlextExceptions, FlextModels, FlextTypes


class FlextDbOracleExceptions(FlextExceptions):
    """Oracle database exceptions following Flext[Area][Module] pattern.

    Single class inheriting from FlextExceptions with all Oracle-specific
    exceptions as internal nested classes, following SOLID principles,
    PEP8, Python 3.13+, and FLEXT structural patterns.

    This class consolidates all Oracle database exceptions functionality
    into a single entry point with internal organization.
    """

    class ExceptionParams(FlextModels.Entity):
        """Parameters for Oracle exception handling."""

        error_code: str = Field(description="Oracle error code")
        message: str = Field(description="Error message")
        context: dict[str, object] = Field(
            default_factory=dict, description="Additional context"
        )
        sql_statement: str | None = Field(default=None, description="SQL statement")
        connection_info: dict[str, str] | None = Field(
            default=None, description="Connection information"
        )

        @field_validator("message")
        @classmethod
        def validate_message(cls, v: str) -> str:
            """Validate that message is not empty or whitespace."""
            if not v or not v.strip():
                msg = "Exception message cannot be empty"
                raise ValueError(msg)
            return v

        class Config:
            """Pydantic config for ExceptionParams."""

            frozen = True  # Make it immutable

    class OracleErrorCodes:
        """Oracle-specific error codes."""

        # Generic FLEXT error codes for Oracle operations
        VALIDATION_ERROR: Final[str] = "ORACLE_VALIDATION_ERROR"
        CONFIGURATION_ERROR: Final[str] = "ORACLE_CONFIGURATION_ERROR"
        CONNECTION_ERROR: Final[str] = "ORACLE_CONNECTION_ERROR"
        PROCESSING_ERROR: Final[str] = "ORACLE_PROCESSING_ERROR"
        AUTHENTICATION_ERROR: Final[str] = "ORACLE_AUTHENTICATION_ERROR"
        TIMEOUT_ERROR: Final[str] = "ORACLE_TIMEOUT_ERROR"
        QUERY_ERROR: Final[str] = "ORACLE_QUERY_ERROR"
        METADATA_ERROR: Final[str] = "ORACLE_METADATA_ERROR"

        # Oracle-specific error codes
        CONNECTION_FAILED: Final[str] = "ORA-12541"
        INVALID_USERNAME: Final[str] = "ORA-01017"
        TABLE_NOT_FOUND: Final[str] = "ORA-00942"
        COLUMN_NOT_FOUND: Final[str] = "ORA-00904"
        TIMEOUT: Final[str] = "ORA-12170"
        NETWORK_ERROR: Final[str] = "ORA-12514"

    class OracleBaseError(FlextExceptions.BaseError):
        """Base Oracle database error."""

        def __init__(self, message: str, **kwargs: object) -> None:
            """Initialize Oracle base error with message and optional context."""
            # Set error_code from code parameter if provided
            if "code" in kwargs:
                kwargs["error_code"] = str(kwargs.pop("code"))

            # Call super().__init__ with explicit parameters
            code = cast("str | None", kwargs.get("error_code"))
            context = cast("dict[str, object] | None", kwargs.get("context"))
            correlation_id = cast("str | None", kwargs.get("correlation_id"))

            super().__init__(
                message, code=code, context=context, correlation_id=correlation_id
            )
            self.oracle_code: str | None = cast("str | None", kwargs.get("oracle_code"))
            self.sql_statement: str | None = cast(
                "str | None", kwargs.get("sql_statement")
            )
            self.connection_info: dict[str, str] | None = cast(
                "dict[str, str] | None", kwargs.get("connection_info")
            )

    class OracleError(OracleBaseError):
        """General Oracle database error."""

        def __init__(self, message: str, **kwargs: object) -> None:
            """Initialize Oracle error with message and optional context."""
            super().__init__(message, **kwargs)
            self.error_type = "OracleError"

    class OracleValidationError(OracleBaseError):
        """Oracle validation error."""

        def __init__(
            self,
            message: str,
            field: str | None = None,
            value: object = None,
            validation_details: str | None = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle validation error with field details."""
            super().__init__(message, **kwargs)
            self.field = field
            self.value = value
            self.validation_details = validation_details
            self.error_type = "ValidationError"

        @classmethod
        def from_field_error(
            cls, field: str, value: object, message: str
        ) -> FlextDbOracleExceptions.OracleValidationError:
            """Create validation error from field details."""
            return cls(
                message=f"Validation failed for field '{field}': {message}",
                field=field,
                value=value,
            )

    class OracleConfigurationError(OracleBaseError):
        """Oracle configuration error."""

        def __init__(
            self,
            message: str,
            config_key: str | None = None,
            config_file: str | None = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle configuration error with config key details."""
            # Build context with configuration details (convert None to "None" string)
            context: dict[str, object] = dict(
                cast("dict[str, object]", kwargs.get("context", {}))
            )
            context["config_key"] = (
                str(config_key) if config_key is not None else "None"
            )
            context["config_file"] = (
                str(config_file) if config_file is not None else "None"
            )
            kwargs["context"] = context

            super().__init__(message, **kwargs)
            self.config_key = config_key
            self.config_file = config_file
            self.error_type = "ConfigurationError"

        @classmethod
        def missing_config(
            cls, key: str
        ) -> FlextDbOracleExceptions.OracleConfigurationError:
            """Create error for missing configuration."""
            return cls(message=f"Missing required configuration: {key}", config_key=key)

    class OracleConnectionError(OracleBaseError):
        """Oracle connection error."""

        def __init__(
            self,
            message: str,
            host: str | None = None,
            port: int | None = None,
            endpoint: str | None = None,
            service: str | None = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle connection error with host and port details."""
            # Build context with connection details
            context: dict[str, object] = dict(
                cast("dict[str, object]", kwargs.get("context", {}))
            )
            context["endpoint"] = str(endpoint) if endpoint is not None else "None"
            context["service"] = str(service) if service is not None else "None"
            kwargs["context"] = context

            super().__init__(message, **kwargs)
            self.host = host
            self.port = port
            self.endpoint = endpoint
            self.service = service
            self.error_type = "ConnectionError"

    class OracleAuthenticationError(OracleBaseError):
        """Oracle authentication error."""

        def __init__(
            self,
            message: str,
            username: str | None = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle authentication error with username details."""
            super().__init__(message, **kwargs)
            self.username = username
            self.error_type = "AuthenticationError"

        @classmethod
        def invalid_credentials(
            cls, username: str
        ) -> FlextDbOracleExceptions.OracleAuthenticationError:
            """Create error for invalid credentials."""
            return cls(
                message=f"Invalid credentials for user: {username}", username=username
            )

    class OracleProcessingError(OracleBaseError):
        """Oracle data processing error."""

        def __init__(
            self,
            message: str,
            operation: str | None = None,
            data_context: dict[str, object] | None = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle processing error with operation and data context."""
            super().__init__(message, **kwargs)
            self.operation = operation
            self.data_context = data_context or {}
            self.error_type = "ProcessingError"

        @classmethod
        def data_conversion_failed(
            cls, operation: str, details: str
        ) -> FlextDbOracleExceptions.OracleProcessingError:
            """Create error for data conversion failures."""
            return cls(
                message=f"Data conversion failed during {operation}: {details}",
                operation=operation,
            )

    class OracleTimeoutError(OracleBaseError):
        """Oracle timeout error."""

        def __init__(
            self,
            message: str,
            timeout_seconds: float | None = None,
            operation: str | None = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle timeout error with timeout and operation details."""
            super().__init__(message, **kwargs)
            self.timeout_seconds = timeout_seconds
            self.operation = operation
            self.error_type = "TimeoutError"

        @classmethod
        def query_timeout(
            cls, timeout_seconds: float, query: str | None = None
        ) -> FlextDbOracleExceptions.OracleTimeoutError:
            """Create error for query timeouts."""
            message = f"Query timed out after {timeout_seconds} seconds"
            if query:
                message += f": {query[:100]}..."
            return cls(
                message=message,
                timeout_seconds=timeout_seconds,
                operation="query_execution",
                sql_statement=query,
            )

    class OracleQueryError(OracleBaseError):
        """Oracle query execution error."""

        def __init__(
            self, message: str, query: str | None = None, **kwargs: object
        ) -> None:
            """Initialize Oracle query error with query details."""
            super().__init__(message, **kwargs)
            self.query = query
            self.error_type = "QueryError"

    class OracleMetadataError(OracleBaseError):
        """Oracle metadata retrieval error."""

        def __init__(
            self, message: str, table_name: str | None = None, **kwargs: object
        ) -> None:
            """Initialize Oracle metadata error with table name details."""
            super().__init__(message, **kwargs)
            self.table_name = table_name
            self.error_type = "MetadataError"

    @classmethod
    def create_validation_error(
        cls, field: str, value: object, message: str
    ) -> FlextDbOracleExceptions.OracleValidationError:
        """Factory method for validation errors."""
        return cls.OracleValidationError.from_field_error(field, value, message)

    @classmethod
    def create_connection_error(
        cls, host: str, port: int, message: str
    ) -> FlextDbOracleExceptions.OracleConnectionError:
        """Factory method for connection errors."""
        return cls.OracleConnectionError(message=message, host=host, port=port)

    @classmethod
    def create_timeout_error(
        cls,
        timeout_seconds: float,
        query: str | None = None,
        message: str | None = None,
    ) -> FlextDbOracleExceptions.OracleTimeoutError:
        """Factory method for timeout errors."""
        if message is None:
            message = f"Operation timed out after {timeout_seconds} seconds"
        return cls.OracleTimeoutError(
            message=message,
            timeout_seconds=timeout_seconds,
            operation="query_execution" if query else "operation",
            sql_statement=query,
            context={"duration": timeout_seconds},
        )

    @classmethod
    def create_metadata_error(
        cls, object_name: str, message: str = "Metadata missing"
    ) -> FlextDbOracleExceptions.OracleMetadataError:
        """Factory method for metadata errors."""
        return cls.OracleMetadataError(message=message, table_name=object_name)

    @classmethod
    def create_configuration_error(
        cls, config_key: str, config_file: str | None = None, message: str | None = None
    ) -> FlextDbOracleExceptions.OracleConfigurationError:
        """Factory method for configuration errors."""
        if message is None:
            message = f"Missing required configuration: {config_key}"
        return cls.OracleConfigurationError(
            message=message, config_key=config_key, config_file=config_file
        )

    @classmethod
    def create_query_error(
        cls, sql: str, message: str = "Query execution failed"
    ) -> FlextDbOracleExceptions.OracleQueryError:
        """Factory method for query errors."""
        return cls.OracleQueryError(message=message, query=sql, context={"sql": sql})

    @staticmethod
    def is_oracle_error(error: Exception) -> bool:
        """Check if error is Oracle-specific."""
        return isinstance(error, FlextDbOracleExceptions.OracleBaseError)

    # Aliases for backward compatibility and convenience
    setattr(FlextDbOracleExceptions, "ValidationError", OracleValidationError)
    setattr(FlextDbOracleExceptions, "ConfigurationError", OracleConfigurationError)
    setattr(FlextDbOracleExceptions, "ConnectionError", OracleConnectionError)
    setattr(FlextDbOracleExceptions, "AuthenticationError", OracleAuthenticationError)
    setattr(FlextDbOracleExceptions, "ProcessingError", OracleProcessingError)
    setattr(FlextDbOracleExceptions, "TimeoutError", OracleTimeoutError)
    setattr(FlextDbOracleExceptions, "QueryError", OracleQueryError)
    setattr(FlextDbOracleExceptions, "MetadataError", OracleMetadataError)


__all__: FlextTypes.Core.StringList = [
    "FlextDbOracleExceptions",
]
