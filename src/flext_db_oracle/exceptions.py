"""Oracle Database exceptions using FLEXT ecosystem patterns.

All Oracle-specific exceptions are automatically generated by flext-core.

Copyright (c) 2025 FLEXT Team. All rights reserved.
SPDX-License-Identifier: MIT
"""

from __future__ import annotations

from typing import Final, cast

from pydantic import Field

from flext_core import FlextExceptions, FlextModels, FlextTypes


class FlextDbOracleExceptions(FlextExceptions):
    """Oracle database exceptions following Flext[Area][Module] pattern.

    Single class inheriting from FlextExceptions with all Oracle-specific
    exceptions as internal nested classes, following SOLID principles,
    PEP8, Python 3.13+, and FLEXT structural patterns.

    This class consolidates all Oracle database exceptions functionality
    into a single entry point with internal organization.
    """

    class ExceptionParams(FlextModels.Entity):
        """Parameters for Oracle exception handling."""

        error_code: str = Field(description="Oracle error code")
        message: str = Field(description="Error message")
        context: dict[str, object] = Field(
            default_factory=dict, description="Additional context"
        )
        sql_statement: str | None = Field(default=None, description="SQL statement")
        connection_info: dict[str, str] | None = Field(
            default=None, description="Connection information"
        )

    class OracleErrorCodes:
        """Oracle-specific error codes."""

        # Generic FLEXT error codes for Oracle operations
        VALIDATION_ERROR: Final[str] = "ORACLE_VALIDATION_ERROR"
        CONFIGURATION_ERROR: Final[str] = "ORACLE_CONFIGURATION_ERROR"
        CONNECTION_ERROR: Final[str] = "ORACLE_CONNECTION_ERROR"
        PROCESSING_ERROR: Final[str] = "ORACLE_PROCESSING_ERROR"
        AUTHENTICATION_ERROR: Final[str] = "ORACLE_AUTHENTICATION_ERROR"
        TIMEOUT_ERROR: Final[str] = "ORACLE_TIMEOUT_ERROR"
        QUERY_ERROR: Final[str] = "ORACLE_QUERY_ERROR"
        METADATA_ERROR: Final[str] = "ORACLE_METADATA_ERROR"

        # Oracle-specific error codes
        CONNECTION_FAILED: Final[str] = "ORA-12541"
        INVALID_USERNAME: Final[str] = "ORA-01017"
        TABLE_NOT_FOUND: Final[str] = "ORA-00942"
        COLUMN_NOT_FOUND: Final[str] = "ORA-00904"
        TIMEOUT: Final[str] = "ORA-12170"
        NETWORK_ERROR: Final[str] = "ORA-12514"

    class OracleBaseError(FlextExceptions.BaseError):
        """Base Oracle database error."""

        def __init__(self, message: str, **kwargs: object) -> None:
            """Initialize Oracle base error with message and optional context."""
            super().__init__(message)
            self.oracle_code: str | None = cast("str | None", kwargs.get("oracle_code"))
            self.sql_statement: str | None = cast(
                "str | None", kwargs.get("sql_statement")
            )
            self.connection_info: dict[str, str] | None = cast(
                "dict[str, str] | None", kwargs.get("connection_info")
            )

    class OracleError(OracleBaseError):
        """General Oracle database error."""

        def __init__(self, message: str, **kwargs: object) -> None:
            """Initialize Oracle error with message and optional context."""
            super().__init__(message, **kwargs)
            self.error_type = "OracleError"

    class OracleValidationError(OracleBaseError):
        """Oracle validation error."""

        def __init__(
            self,
            message: str,
            field: str | None = None,
            value: object = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle validation error with field details."""
            super().__init__(message, **kwargs)
            self.field = field
            self.value = value
            self.error_type = "ValidationError"

        @classmethod
        def from_field_error(
            cls, field: str, value: object, message: str
        ) -> FlextDbOracleExceptions.OracleValidationError:
            """Create validation error from field details."""
            return cls(
                message=f"Validation failed for field '{field}': {message}",
                field=field,
                value=value,
            )

    class OracleConfigurationError(OracleBaseError):
        """Oracle configuration error."""

        def __init__(
            self, message: str, config_key: str | None = None, **kwargs: object
        ) -> None:
            """Initialize Oracle configuration error with config key details."""
            super().__init__(message, **kwargs)
            self.config_key = config_key
            self.error_type = "ConfigurationError"

        @classmethod
        def missing_config(
            cls, key: str
        ) -> FlextDbOracleExceptions.OracleConfigurationError:
            """Create error for missing configuration."""
            return cls(message=f"Missing required configuration: {key}", config_key=key)

    class OracleConnectionError(OracleBaseError):
        """Oracle connection error."""

        def __init__(
            self,
            message: str,
            host: str | None = None,
            port: int | None = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle connection error with host and port details."""
            super().__init__(message, **kwargs)
            self.host = host
            self.port = port
            self.error_type = "ConnectionError"

    class OracleAuthenticationError(OracleBaseError):
        """Oracle authentication error."""

        def __init__(
            self,
            message: str,
            username: str | None = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle authentication error with username details."""
            super().__init__(message, **kwargs)
            self.username = username
            self.error_type = "AuthenticationError"

        @classmethod
        def invalid_credentials(
            cls, username: str
        ) -> FlextDbOracleExceptions.OracleAuthenticationError:
            """Create error for invalid credentials."""
            return cls(
                message=f"Invalid credentials for user: {username}", username=username
            )

    class OracleProcessingError(OracleBaseError):
        """Oracle data processing error."""

        def __init__(
            self,
            message: str,
            operation: str | None = None,
            data_context: dict[str, object] | None = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle processing error with operation and data context."""
            super().__init__(message, **kwargs)
            self.operation = operation
            self.data_context = data_context or {}
            self.error_type = "ProcessingError"

        @classmethod
        def data_conversion_failed(
            cls, operation: str, details: str
        ) -> FlextDbOracleExceptions.OracleProcessingError:
            """Create error for data conversion failures."""
            return cls(
                message=f"Data conversion failed during {operation}: {details}",
                operation=operation,
            )

    class OracleTimeoutError(OracleBaseError):
        """Oracle timeout error."""

        def __init__(
            self,
            message: str,
            timeout_seconds: float | None = None,
            operation: str | None = None,
            **kwargs: object,
        ) -> None:
            """Initialize Oracle timeout error with timeout and operation details."""
            super().__init__(message, **kwargs)
            self.timeout_seconds = timeout_seconds
            self.operation = operation
            self.error_type = "TimeoutError"

        @classmethod
        def query_timeout(
            cls, timeout_seconds: float, query: str | None = None
        ) -> FlextDbOracleExceptions.OracleTimeoutError:
            """Create error for query timeouts."""
            message = f"Query timed out after {timeout_seconds} seconds"
            if query:
                message += f": {query[:100]}..."
            return cls(
                message=message,
                timeout_seconds=timeout_seconds,
                operation="query_execution",
                sql_statement=query,
            )

    class OracleQueryError(OracleBaseError):
        """Oracle query execution error."""

        def __init__(
            self, message: str, query: str | None = None, **kwargs: object
        ) -> None:
            """Initialize Oracle query error with query details."""
            super().__init__(message, **kwargs)
            self.query = query
            self.error_type = "QueryError"

    class OracleMetadataError(OracleBaseError):
        """Oracle metadata retrieval error."""

        def __init__(
            self, message: str, table_name: str | None = None, **kwargs: object
        ) -> None:
            """Initialize Oracle metadata error with table name details."""
            super().__init__(message, **kwargs)
            self.table_name = table_name
            self.error_type = "MetadataError"

    @classmethod
    def create_validation_error(
        cls, field: str, value: object, message: str
    ) -> FlextDbOracleExceptions.OracleValidationError:
        """Factory method for validation errors."""
        return cls.OracleValidationError.from_field_error(field, value, message)

    @classmethod
    def create_connection_error(
        cls, host: str, port: int, message: str
    ) -> FlextDbOracleExceptions.OracleConnectionError:
        """Factory method for connection errors."""
        return cls.OracleConnectionError(message=message, host=host, port=port)

    @staticmethod
    def is_oracle_error(error: Exception) -> bool:
        """Check if error is Oracle-specific."""
        return isinstance(error, FlextDbOracleExceptions.OracleBaseError)


__all__: FlextTypes.Core.StringList = [
    "FlextDbOracleExceptions",
]
